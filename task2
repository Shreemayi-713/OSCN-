#include <iostream>
#include <string>
using namespace std;

// XOR function for binary strings
string xor1(string a, string b) {
    string result = "";
    for (int i = 1; i < b.size(); i++)
        result += (a[i] == b[i]) ? '0' : '1';
    return result;
}

// Perform Modulo-2 Division
string mod2div(string dividend, string divisor) {
    int pick = divisor.size();
    string tmp = dividend.substr(0, pick);
    int n = dividend.size();

    while (pick < n) {
        if (tmp[0] == '1')
            tmp = xor1(divisor, tmp) + dividend[pick];
        else
            tmp = xor1(string(pick, '0'), tmp) + dividend[pick];
        pick++;
    }

    if (tmp[0] == '1')
        tmp = xor1(divisor, tmp);
    else
        tmp = xor1(string(pick, '0'), tmp);

    return tmp.substr(tmp.size() - (divisor.size() - 1));
}

int main() {
    string data = "10011101";
    string divisor = "1001";  // x^3 + 1

    // Step 1: Append zeros
    string appended_data = data + string(divisor.size() - 1, '0');

    // Step 2: Compute remainder
    string remainder = mod2div(appended_data, divisor);

    // Step 3: Transmitted frame
    string transmitted = data + remainder;

    cout << "Original Data: " << data << endl;
    cout << "Generator: " << divisor << endl;
    cout << "Appended Data: " << appended_data << endl;
    cout << "Remainder (CRC): " << remainder << endl;
    cout << "Transmitted Frame: " << transmitted << endl;

    // Step 4: Introduce error (invert 3rd bit)
    string received = transmitted;
    received[2] = (received[2] == '0') ? '1' : '0';
    cout << "\nReceived Frame (with error): " << received << endl;

    // Step 5: Receiver side CRC check
    string remainder_rx = mod2div(received, divisor);

    cout << "Receiver Remainder: " << remainder_rx << endl;
    if (remainder_rx.find('1') != string::npos)
        cout << "Error detected during transmission!" << endl;
    else
        cout << "No error detected." << endl;

    return 0;
}
